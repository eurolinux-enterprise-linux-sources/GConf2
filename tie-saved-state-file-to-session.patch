From 6286d724e880dbfa7042e49936cc18ed8077eb03 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Fri, 10 Jun 2011 11:25:55 -0400
Subject: [PATCH 1/3] daemon: store saved_state in daemon dir not ~/.gconfd

The daemon dir isn't always ~/.gconfd so we shouldn't hard
code it.

https://bugzilla.gnome.org/show_bug.cgi?id=652289
---
 gconf/gconfd.c | 8 +-------
 1 file changed, 1 insertion(+), 7 deletions(-)

diff --git a/gconf/gconfd.c b/gconf/gconfd.c
index dc928d4..a227cda 100644
--- a/gconf/gconfd.c
+++ b/gconf/gconfd.c
@@ -1519,67 +1519,61 @@ gconfd_check_in_shutdown (CORBA_Environment *ev)
  */
 
 /*
    The log file records the current listeners we have registered,
    so we can restore them if we exit and restart.
 
    Basically:
 
    1) On startup, we parse any logfile and try to restore the
       listeners contained therein. As we restore each listener (give
       clients a new listener ID) we append a removal of the previous
       daemon's listener and the addition of our own listener to the
       logfile; this means that if we crash and have to restore a
       client's listener a second time, we'll have the client's current
       listener ID. If all goes well we then atomically rewrite the
       parsed logfile with the resulting current state, to keep the logfile
       compact.
 
    2) While running, we keep a FILE* open and whenever we add/remove
       a listener we write a line to the logfile recording it,
       to keep the logfile always up-to-date.
 
    3) On normal exit, and also periodically (every hour or so, say) we
       atomically write over the running log with our complete current
       state, to keep the running log from growing without bound.
 */
 
 static void
 get_log_names (gchar **logdir, gchar **logfile)
 {
-#ifndef G_OS_WIN32
-      const char *home = g_get_home_dir ();
-#else
-      const char *home = _gconf_win32_get_home_dir ();
-#endif
-
-  *logdir = g_build_filename (home, ".gconfd", NULL);
+  *logdir = gconf_get_daemon_dir ();
   *logfile = g_build_filename (*logdir, "saved_state", NULL);
 }
 
 static void close_append_handle (void);
 
 static FILE* append_handle = NULL;
 static guint append_handle_timeout = 0;
 
 static gboolean
 close_append_handle_timeout(gpointer data)
 {
   close_append_handle ();
 
   /* uninstall the timeout */
   append_handle_timeout = 0;
   return FALSE;
 }
 
 static gboolean
 open_append_handle (GError **err)
 {
   if (append_handle == NULL)
     {
       gchar *logdir;
       gchar *logfile;
 
       get_log_names (&logdir, &logfile);
       
       g_mkdir (logdir, 0700); /* ignore failure, we'll catch failures
 			       * that matter on open()
-- 
2.7.4


From 265b324e61dcb33e4f7761eea5010d7fb0c6034c Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Fri, 10 Jun 2011 18:47:41 -0400
Subject: [PATCH 2/3] daemon: store daemon data in XDG_RUNTIME_DIR

If XDG_RUNTIME_DIR is available it's a much better
directory than /tmp since it ensures there's no
DoS possibilities

https://bugzilla.gnome.org/show_bug.cgi?id=652289
---
 gconf/gconf-internals.c | 19 ++++++++++++-------
 1 file changed, 12 insertions(+), 7 deletions(-)

diff --git a/gconf/gconf-internals.c b/gconf/gconf-internals.c
index 3d61e1e..472b472 100644
--- a/gconf/gconf-internals.c
+++ b/gconf/gconf-internals.c
@@ -2783,67 +2783,72 @@ gconf_orb_release (void)
       CORBA_ORB orb = gconf_orb;
       CORBA_Environment ev;
 
       gconf_orb = CORBA_OBJECT_NIL;
 
       CORBA_exception_init (&ev);
 
       CORBA_ORB_destroy (orb, &ev);
       CORBA_Object_release ((CORBA_Object)orb, &ev);
 
       if (ev._major != CORBA_NO_EXCEPTION)
         {
           ret = 1;
         }
       CORBA_exception_free (&ev);
     }
 
   return ret;
 }
 
 char*
 gconf_get_daemon_dir (void)
 {  
   if (gconf_use_local_locks ())
     {
       char *s;
       char *subdir;
       const char *tmpdir;
 
       subdir = g_strconcat ("gconfd-", g_get_user_name (), NULL);
-      
-      if (g_getenv ("GCONF_TMPDIR")) {
-	tmpdir = g_getenv ("GCONF_TMPDIR");
-      } else {
-	tmpdir = g_get_tmp_dir ();
-      }
-      
+
+      if (g_getenv ("GCONF_TMPDIR"))
+        tmpdir = g_getenv ("GCONF_TMPDIR");
+      else if (g_getenv ("XDG_RUNTIME_DIR"))
+        {
+          g_free (subdir);
+          subdir = g_strdup ("gconfd");
+          tmpdir = g_getenv ("XDG_RUNTIME_DIR");
+        }
+      else
+        tmpdir = g_get_tmp_dir ();
+
       s = g_build_filename (tmpdir, subdir, NULL);
 
       g_free (subdir);
 
       return s;
     }
   else
     {
 #ifndef G_OS_WIN32
       const char *home = g_get_home_dir ();
 #else
       const char *home = _gconf_win32_get_home_dir ();
 #endif
       return g_strconcat (home, "/.gconfd", NULL);
     }
 }
 
 char*
 gconf_get_lock_dir (void)
 {
   char *gconfd_dir;
   char *lock_dir;
   
   gconfd_dir = gconf_get_daemon_dir ();
   lock_dir = g_strconcat (gconfd_dir, "/lock", NULL);
 
   g_free (gconfd_dir);
   return lock_dir;
 }
 
-- 
2.7.4


From 0d4b1aaec836b127c7c92cd50d61e6d5a7fab5b8 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Fri, 10 Jun 2011 14:38:49 -0400
Subject: [PATCH 3/3] daemon: tie saved_state file to session

The code isn't really designed to work well with multiple
gconfd's writing to the same saved_state file, so we should
make it per-session.

https://bugzilla.gnome.org/show_bug.cgi?id=652289
---
 gconf/gconfd.c | 82 +++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 79 insertions(+), 3 deletions(-)

diff --git a/gconf/gconfd.c b/gconf/gconfd.c
index a227cda..6286c16 100644
--- a/gconf/gconfd.c
+++ b/gconf/gconfd.c
@@ -30,60 +30,62 @@
 #include "gconf-internals.h"
 #include "gconf-sources.h"
 #include "gconf-listeners.h"
 #include "gconf-locale.h"
 #include "gconf-schema.h"
 #include "gconf.h"
 #include "gconfd.h"
 #include "gconf-database.h"
 #include <orbit/orbit.h>
 
 #include "GConfX.h"
 
 #include <sys/types.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
 #include <unistd.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <ctype.h>
 #include <time.h>
 #ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
 #endif
 #include <locale.h>
 
 #include <dbus/dbus-glib-lowlevel.h>
 
+static void logfile_remove (void);
+
 #ifdef G_OS_WIN32
 #include <io.h>
 #include <conio.h>
 #define _WIN32_WINNT 0x0500 
 #include <windows.h>
 #endif
 
 /* This makes hash table safer when debugging */
 #ifndef GCONF_ENABLE_DEBUG
 #define safe_g_hash_table_insert g_hash_table_insert
 #else
 static void
 safe_g_hash_table_insert(GHashTable* ht, gpointer key, gpointer value)
 {
   gpointer oldkey = NULL, oldval = NULL;
 
   if (g_hash_table_lookup_extended(ht, key, &oldkey, &oldval))
     {
       gconf_log(GCL_WARNING, "Hash key `%s' is already in the table!",
                 (gchar*) key);
       return;
     }
   else
     {
       g_hash_table_insert(ht, key, value);
     }
 }
 #endif
 
 /*
@@ -109,60 +111,66 @@ static guint   client_count          (void);
 static void    enter_shutdown          (void);
 
 static void                 init_databases (void);
 static void                 shutdown_databases (void);
 static void                 set_default_database (GConfDatabase* db);
 static void                 register_database (GConfDatabase* db);
 static void                 unregister_database (GConfDatabase* db);
 static GConfDatabase*       lookup_database (GSList *addresses);
 static GConfDatabase*       obtain_database (GSList *addresses,
                                              GError **err);
 static void                 drop_old_databases (void);
 static gboolean             no_databases_in_use (void);
 
 static void gconf_handle_segv (int signum);
 
 /*
  * Flag indicating that we are shutting down, so return errors
  * on any attempted operation. We do this instead of unregistering with
  * OAF or deactivating the server object, because we want to avoid
  * another gconfd starting up before we finish shutting down.
  */
 
 static gboolean in_shutdown = FALSE;
 
 /*
  * Flag indicating we received a SIGHUP and we should reaload
  * all sources during the next periodic_cleanup()
  */
 static gboolean need_db_reload = FALSE;
 
+/*
+ * Flag indicating whether to prepare for respawn or logout
+ * when exiting
+ */
+static gboolean clean_shutdown_requested = FALSE;
+
 /* 
  * CORBA goo
  */
 
 static ConfigServer2 server = CORBA_OBJECT_NIL;
 static PortableServer_POA the_poa;
 static GConfLock *daemon_lock = NULL;
 
 static ConfigDatabase
 gconfd_get_default_database(PortableServer_Servant servant,
                             CORBA_Environment* ev);
 
 static ConfigDatabase
 gconfd_get_database(PortableServer_Servant servant,
                     const CORBA_char* address,
                     CORBA_Environment* ev);
 
 static ConfigDatabase
 gconfd_get_database_for_addresses (PortableServer_Servant           servant,
 				   const ConfigServer2_AddressList *addresses,
 				   CORBA_Environment               *ev);
 
 static void
 gconfd_add_client (PortableServer_Servant servant,
                    const ConfigListener client,
                    CORBA_Environment *ev);
 
 static void
 gconfd_remove_client (PortableServer_Servant servant,
                       const ConfigListener client,
@@ -280,60 +288,61 @@ gconfd_add_client (PortableServer_Servant servant,
 }
 
 static void
 gconfd_remove_client (PortableServer_Servant servant,
                       const ConfigListener client,
                       CORBA_Environment *ev)
 {
   if (gconfd_check_in_shutdown (ev))
     return;
   
   remove_client (client);
 }
 
 static CORBA_long
 gconfd_ping(PortableServer_Servant servant, CORBA_Environment *ev)
 {
   if (gconfd_check_in_shutdown (ev))
     return 0;
   
   return getpid();
 }
 
 static void
 gconfd_shutdown(PortableServer_Servant servant, CORBA_Environment *ev)
 {
   if (gconfd_check_in_shutdown (ev))
     return;
   
   gconf_log(GCL_DEBUG, _("Shutdown request received"));
 
+  clean_shutdown_requested = TRUE;
   gconf_main_quit();
 }
 
 /*
  * Main code
  */
 
 /* This needs to be called before we register with OAF
  */
 static void
 gconf_server_load_sources(void)
 {
   GSList* addresses;
   GList* tmp;
   gboolean have_writable = FALSE;
   gchar* conffile;
   GConfSources* sources = NULL;
   GError* error = NULL;
   
   conffile = g_strconcat(GCONF_CONFDIR, "/path", NULL);
 
   addresses = gconf_load_source_path(conffile, NULL);
 
   g_free(conffile);
 
 #ifdef GCONF_ENABLE_DEBUG
   /* -- Debug only */
   
   if (addresses == NULL)
     {
@@ -429,142 +438,151 @@ signal_handler (int signo)
     return;
   
   ++in_fatal;
   
   switch (signo) {
     /* Fast cleanup only */
   case SIGSEGV:
 #ifdef SIGBUS
   case SIGBUS:
 #endif
   case SIGILL:
     enter_shutdown ();
 #ifndef G_OS_WIN32
     if (g_getenv ("DISPLAY"))
       gconf_handle_segv (signo);
 #else
     gconf_handle_segv (signo);
 #endif
     abort ();
     break;
 
   case SIGFPE:
 #ifdef SIGPIPE
   case SIGPIPE:
 #endif
     /* Go ahead and try the full cleanup on these,
      * though it could well not work out very well.
      */
     enter_shutdown ();
 
+    clean_shutdown_requested = FALSE;
+
     /* let the fatal signals interrupt us */
     --in_fatal;
     
     if (gconf_main_is_running ())
       gconf_main_quit ();
     
     break;
 
   case SIGTERM:
     enter_shutdown ();
 
+    clean_shutdown_requested = TRUE;
+
     /* let the fatal signals interrupt us */
     --in_fatal;
     
     if (gconf_main_is_running ())
       gconf_main_quit ();
     break;
 
 #ifdef SIGHUP
   case SIGHUP:
     --in_fatal;
 
     /* reload sources during next periodic_cleanup() */
     need_db_reload = TRUE;
     break;
 #endif
 
 #ifdef SIGUSR1
   case SIGUSR1:
     --in_fatal;
     
     /* it'd be nice to log a message here but it's not very safe, so */
     gconf_log_debug_messages = !gconf_log_debug_messages;
     break;
 #endif
     
   default:
+    clean_shutdown_requested = FALSE;
 #ifndef HAVE_SIGACTION
     signal (signo, signal_handler);
 #endif
     break;
   }
 }
 
 PortableServer_POA
 gconf_get_poa (void)
 {
   return the_poa;
 }
 
 static const char *
 get_introspection_xml (void)
 {
   return "<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\"\n"
          "\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"
          "<node>\n"
          "  <interface name=\"org.freedesktop.DBus.Introspectable\">\n"
          "    <method name=\"Introspect\">\n"
          "      <arg name=\"introspection_xml\" direction=\"out\" type=\"s\"/>\n"
          "    </method>\n"
          "  </interface>\n"
          "  <interface name=\"org.gnome.GConf\">\n"
          "    <method name=\"GetIOR\">\n"
          "      <arg name=\"ior\" direction=\"out\" type=\"s\"/>\n"
          "    </method>\n"
          "  </interface>\n"
          "</node>\n";
 }
 
 static DBusHandlerResult
 bus_message_handler (DBusConnection *connection,
                      DBusMessage    *message,
                      void           *user_data)
 {
   DBusMessage *reply;
 
   reply = NULL;
 
   if (dbus_message_is_signal (message,
                               DBUS_INTERFACE_LOCAL,
                               "Disconnected"))
     {
+      /* Since the log file is per-session, we should make sure it's
+       * removed when the session is over.
+       */
+      clean_shutdown_requested = TRUE;
       gconf_main_quit ();
       return DBUS_HANDLER_RESULT_HANDLED;
     }
   else if (dbus_message_is_method_call (message,
                                         "org.freedesktop.DBus.Introspectable",
                                         "Introspect"))
     {
       const char *introspection_xml;
 
       introspection_xml = get_introspection_xml ();
 
       reply = dbus_message_new_method_return (message);
       dbus_message_append_args (reply, DBUS_TYPE_STRING, &introspection_xml,
                                 DBUS_TYPE_INVALID);
 
     }
   else if (dbus_message_is_method_call (message,
                                         "org.gnome.GConf",
                                         "GetIOR"))
     {
       const char *ior;
 
       ior = gconf_get_daemon_ior ();
 
       reply = dbus_message_new_method_return (message);
       dbus_message_append_args (reply, DBUS_TYPE_STRING, &ior, DBUS_TYPE_INVALID);
     }
 
   if (reply != NULL)
     {
@@ -921,63 +939,67 @@ main(int argc, char** argv)
       
       close (write_byte_fd);
     }
   
   if (connection == NULL)
     {
       enter_shutdown ();
       shutdown_databases ();
       
       return 1;
     }  
 
   /* Read saved log file, if any */
   logfile_read ();
  
 #ifdef ENABLE_DEFAULTS_SERVICE 
   get_on_system_bus ();
 #endif
 
   gconf_main ();
 
   if (in_shutdown)
     exit_code = 1; /* means someone already called enter_shutdown() */
   
   /* This starts bouncing all incoming requests (and we aren't running
    * the main loop anyway, so they won't get processed)
    */
   enter_shutdown ();
 
   /* Save current state in logfile (may compress the logfile a good
-   * bit)
+   * bit) if we're exiting but may respawn.  Clean up the logfile, if
+   * the session is going away.
    */
-  logfile_save ();
+  if (clean_shutdown_requested)
+    logfile_remove ();
+  else
+    logfile_save ();
   
   shutdown_databases ();
 
   gconfd_locale_cache_drop ();
 
   if (daemon_lock)
     {
       err = NULL;
       gconf_release_lock (daemon_lock, &err);
       if (err != NULL)
         {
           gconf_log (GCL_WARNING, _("Error releasing lockfile: %s"),
                      err->message);
           g_error_free (err);
         }
     }
 
   daemon_lock = NULL;
   
   gconf_log (GCL_DEBUG, _("Exiting"));
 
   return exit_code;
 }
 
 /*
  * Main loop
  */
 
 static GSList* main_loops = NULL;
 static guint timeout_id = 0;
@@ -1491,90 +1513,129 @@ gconf_set_exception(GError** error,
     *error = NULL;
       
     return TRUE;
   }
 }
 
 gboolean
 gconfd_check_in_shutdown (CORBA_Environment *ev)
 {
   if (in_shutdown)
     {
       ConfigException* ce;
       
       ce = ConfigException__alloc();
       ce->message = CORBA_string_dup("Configuration server is currently shutting down");
       ce->err_no = ConfigInShutdown;
 
       CORBA_exception_set(ev, CORBA_USER_EXCEPTION,
                           ex_ConfigException, ce);
 
       return TRUE;
     }
   else
     return FALSE;
 }
 
 /*
  * Logging
  */
 
+static const char *
+get_session_guid (void)
+{
+  const char *session_bus_address;
+  const char *guid;
+
+  /* FIXME: we may want to use dbus-address.h functions here
+   */
+  session_bus_address = g_getenv ("DBUS_SESSION_BUS_ADDRESS");
+
+  if (session_bus_address == NULL)
+    return NULL;
+
+  guid = g_strrstr (session_bus_address, "guid=");
+
+  if (guid == NULL)
+    return NULL;
+
+  if (guid[0] == '\0')
+    return NULL;
+
+  return guid + strlen ("guid=");
+}
+
 /*
    The log file records the current listeners we have registered,
    so we can restore them if we exit and restart.
 
    Basically:
 
    1) On startup, we parse any logfile and try to restore the
       listeners contained therein. As we restore each listener (give
       clients a new listener ID) we append a removal of the previous
       daemon's listener and the addition of our own listener to the
       logfile; this means that if we crash and have to restore a
       client's listener a second time, we'll have the client's current
       listener ID. If all goes well we then atomically rewrite the
       parsed logfile with the resulting current state, to keep the logfile
       compact.
 
    2) While running, we keep a FILE* open and whenever we add/remove
       a listener we write a line to the logfile recording it,
       to keep the logfile always up-to-date.
 
    3) On normal exit, and also periodically (every hour or so, say) we
       atomically write over the running log with our complete current
       state, to keep the running log from growing without bound.
 */
 
 static void
 get_log_names (gchar **logdir, gchar **logfile)
 {
+  const char *session_guid;
+  char *state_file;
+
   *logdir = gconf_get_daemon_dir ();
-  *logfile = g_build_filename (*logdir, "saved_state", NULL);
+
+  /* We make the state file per-session so multiple gconfds
+   * don't stomp over each other.
+   */
+  session_guid = get_session_guid ();
+
+  if (session_guid != NULL)
+    state_file = g_strdup_printf ("saved_state_%s", session_guid);
+  else
+    state_file = g_strdup ("saved_state");
+
+  *logfile = g_build_filename (*logdir, state_file, NULL);
+  g_free (state_file);
 }
 
 static void close_append_handle (void);
 
 static FILE* append_handle = NULL;
 static guint append_handle_timeout = 0;
 
 static gboolean
 close_append_handle_timeout(gpointer data)
 {
   close_append_handle ();
 
   /* uninstall the timeout */
   append_handle_timeout = 0;
   return FALSE;
 }
 
 static gboolean
 open_append_handle (GError **err)
 {
   if (append_handle == NULL)
     {
       gchar *logdir;
       gchar *logfile;
 
       get_log_names (&logdir, &logfile);
       
       g_mkdir (logdir, 0700); /* ignore failure, we'll catch failures
 			       * that matter on open()
 			       */
@@ -1743,60 +1804,75 @@ logfile_save (void)
       if (tmpfile2)
         {
           if (g_rename (tmpfile2, logfile) < 0)
             {
               gconf_log (GCL_WARNING,
                          _("Failed to restore original saved state file that had been moved to '%s': %s"),
                          tmpfile2, g_strerror (errno));
 
             }
         }
       
       goto out;
     }
 
   /* Get rid of original saved state file if everything succeeded */
   if (tmpfile2)
     g_unlink (tmpfile2);
   
  out:
   if (saveme)
     g_string_free (saveme, TRUE);
   g_free (logdir);
   g_free (logfile);
   g_free (tmpfile);
   g_free (tmpfile2);
 
   if (fd >= 0)
     close (fd);
 }
 
+static void
+logfile_remove (void)
+{
+  gchar *logdir = NULL;
+  gchar *logfile = NULL;
+
+  get_log_names (&logdir, &logfile);
+
+  g_unlink (logfile);
+
+  g_free (logdir);
+  g_free (logfile);
+}
+
+
 typedef struct _ListenerLogEntry ListenerLogEntry;
 
 struct _ListenerLogEntry
 {
   guint connection_id;
   gchar *ior;
   gchar *address;
   gchar *location;
 };
 
 static guint
 listener_logentry_hash (gconstpointer v)
 {
   const ListenerLogEntry *lle = v;
 
   return
     (lle->connection_id         & 0xff000000) |
     (g_str_hash (lle->ior)      & 0x00ff0000) |
     (g_str_hash (lle->address)  & 0x0000ff00) |
     (g_str_hash (lle->location) & 0x000000ff);
 }
 
 static gboolean
 listener_logentry_equal (gconstpointer ap, gconstpointer bp)
 {
   const ListenerLogEntry *a = ap;
   const ListenerLogEntry *b = bp;
 
   return
     a->connection_id == b->connection_id &&
-- 
2.7.4

